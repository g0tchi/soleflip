import pytest
from unittest.mock import MagicMock, AsyncMock, patch
from uuid import uuid4

from sqlalchemy.ext.asyncio import AsyncSession
from domains.inventory.services.inventory_service import InventoryService
from shared.database.models import Product, InventoryItem

pytestmark = pytest.mark.asyncio

@pytest.fixture
def mock_db_session():
    return AsyncMock(spec=AsyncSession)

@pytest.fixture
def inventory_service(mock_db_session):
    # Mock the repositories that are initialized within the service
    with patch('domains.inventory.services.inventory_service.ProductRepository') as MockProductRepo, \
         patch('domains.inventory.services.inventory_service.BaseRepository') as MockBaseRepo:

        service = InventoryService(db_session=mock_db_session)
        # Attach mocks to the instance so we can assert calls on them
        service.product_repo = MockProductRepo.return_value
        service.brand_repo = MockBaseRepo.return_value
        service.category_repo = MockBaseRepo.return_value
        service.size_repo = MockBaseRepo.return_value
        service.inventory_repo = MockBaseRepo.return_value
        return service

async def test_enrich_inventory_item_from_stockx_success(inventory_service):
    """
    Tests that an inventory item is successfully enriched with data from StockX.
    """
    # Arrange
    item_id = uuid4()
    mock_item = InventoryItem(
        id=item_id,
        external_ids={"stockx_variant_id": "variant-123"},
        product=Product(sku="SKU-456")
    )

    inventory_service.inventory_repo.get_by_id_with_related.return_value = mock_item

    stockx_api_response = {
        "variantId": "variant-123",
        "isFlexEligible": True
    }

    # We need to patch the StockXService that is instantiated inside the method
    with patch('domains.inventory.services.inventory_service.StockXService', new_callable=MagicMock) as MockStockXService:
        mock_stockx_instance = MockStockXService.return_value
        mock_stockx_instance.get_variant_details = AsyncMock(return_value=stockx_api_response)

        # Act
        enriched_item = await inventory_service.enrich_inventory_item_from_stockx(item_id)

        # Assert
        inventory_service.inventory_repo.get_by_id_with_related.assert_called_once_with(item_id, ["product"])
        mock_stockx_instance.get_variant_details.assert_called_once_with("SKU-456", "variant-123")

        # This part of the test would be built out once the model has a field to update
        # For now, we just assert that the function ran and returned the item
        assert enriched_item is not None
        inventory_service.db_session.commit.assert_not_called() # Because we don't modify the item yet

async def test_enrich_item_not_found_in_db(inventory_service):
    """
    Tests that the function returns None if the inventory item is not in our database.
    """
    # Arrange
    item_id = uuid4()
    inventory_service.inventory_repo.get_by_id_with_related.return_value = None

    # Act
    result = await inventory_service.enrich_inventory_item_from_stockx(item_id)

    # Assert
    assert result is None

async def test_enrich_item_missing_external_id(inventory_service):
    """
    Tests that the function returns the item without calling StockX if the external_id is missing.
    """
    # Arrange
    item_id = uuid4()
    mock_item = InventoryItem(id=item_id, external_ids={}) # No stockx_variant_id
    inventory_service.inventory_repo.get_by_id_with_related.return_value = mock_item

    with patch('domains.inventory.services.inventory_service.StockXService', new_callable=MagicMock) as MockStockXService:
        mock_stockx_instance = MockStockXService.return_value

        # Act
        result = await inventory_service.enrich_inventory_item_from_stockx(item_id)

        # Assert
        assert result is not None
        mock_stockx_instance.get_variant_details.assert_not_called()
